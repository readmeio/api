/* eslint-disable prettier/prettier */
import type Oas from 'oas';
import type { Operation } from 'oas';
import type { JSONSchema, SchemaObject } from 'oas/@types/rmoas.types';
// import type { SchemaWrapper } from 'oas/@types/operation/get-parameters-as-json-schema';

import * as ts from 'typescript';
import { compile } from 'json-schema-to-typescript';

import { OpenAPIV3 } from 'openapi-types';
import * as cg from './oaz/tscodegen';
import ApiGenerator from './oaz/generate';

type ResponseJsonSchema = {
  type: string | string[];
  schema: SchemaObject;
  label: string;
  description?: string;
};

async function convertJSONSchemaToTypescript(schema: JSONSchema, name: string) {
  // Though our JSON Schema type exposes JSONSchema4, which `json-schema-to-typescript`, it won't
  // accept our custom type.
  const interfaceCode = await compile(schema as any, name, {
    bannerComment: '',
  });

  // Because the `name` that we're passing to `json-schema-to-typescript` gets run through some
  // internal logic there and won't always be what we supply it we need to parse the TS that that
  // library creates so we can grab the interface name for use in our own autogenerated code.
  const sourceFile = ts.createSourceFile(`${name}.d.ts`, interfaceCode, ts.ScriptTarget.Latest);

  let typeName;
  await ts.forEachChild(sourceFile, node => {
    if (node.kind === ts.SyntaxKind.EndOfFileToken) {
      return;
    }

    if (ts.isInterfaceDeclaration(node)) {
      // The Node `name` property, an `IdentifierObject`, is not formally exposed in the TS types
      // and there aren't any accessors for this either.
      typeName = node.name.text;
    } else if (ts.isTypeAliasDeclaration(node)) {
      typeName = node.name.text;
    }
  });

  return {
    typeName,
    type: interfaceCode,
  };
}

async function loadOperationsAndMethods(spec: Oas) {
  const operations: Record<
    /* operationId */ string,
    { types: { params: any; responses?: any }; operation: Operation }
  > = {};

  const methods: Record<
    /* method */ string,
    Record</* path */ string, { types: { params: any; responses?: any }; operation: Operation }>
  > = {};

  await Promise.all(
    Object.entries(spec.getPaths()).map(async ([path, ops]) => {
      await Promise.all(
        Object.entries(ops).map(async ([method, operation]) => {
          // if (!(method in methods)) {
          //   methods[method] = {};
          // }

          const operationId = operation.getOperationId();

          let params;
          // @todo we should be smarter about how we're compiling json schema for these so we bundle all metadata types together under one `allOf` type -- it's dumb to have 3+ types be present with a union on a single method param
          const paramSchemas = operation.getParametersAsJsonSchema();
          if (paramSchemas) {
            params = await Promise.resolve(paramSchemas.map(param => ({ [param.type]: param.schema })))
              .then(res => res.reduce((prev, next) => Object.assign(prev, next)))
              .then(res => {
                return Promise.all(
                  Object.entries(res).map(async ([paramType, schema]) => {
                    // @todo add tests for when schema is `{ type: string }`
                    return {
                      [paramType]: {
                        schema,
                        ts: await convertJSONSchemaToTypescript(
                          schema as JSONSchema,
                          `${operationId}_${paramType}_param`
                        ),
                      }
                    };
                  })
                );
              });
          }

          // @todo what does this do for a spec that has no responses?
          let responses;
          // const responses = await Promise.resolve(
          //   operation
          //     .getResponseStatusCodes()
          //     .map(status => {
          //       const schema = operation.getResponseAsJsonSchema(status);
          //       if (!schema) {
          //         return false;
          //       }

          //       return {
          //         [status]: schema.shift() as ResponseJsonSchema,
          //       };
          //     })
          //     .reduce((prev, next) => Object.assign(prev, next))
          // ).then(res => {
          //   return Promise.all(
          //     Object.entries(res as Record<string, ResponseJsonSchema>).map(async ([status, jsonSchema]) => {
          //       return {
          //         [status]: await convertJSONSchemaToTypescript(
          //           jsonSchema.schema as JSONSchema,
          //           `${operationId}_Response_${status}`
          //         ),
          //       };
          //     })
          //   );
          // });

          // methods[method][path] = { types: { params, responses }, operation };
          if (operation.hasOperationId()) {
            operations[operation.getOperationId()] = {
              types: { params, responses },
              operation,
            };
          }
        })
      );
    })
  );

  return [operations, methods];
}

export default async function generator(spec: Oas) {
  // const [operations, methods] = await loadOperationsAndMethods(spec);

  // type Opts = {
  //   include?: string[];
  //   exclude?: string[];
  //   optimistic?: boolean;
  // };

  const ast = new ApiGenerator(spec.api as OpenAPIV3.Document).generateApi();
  const src = cg.printFile(ast);

  console.log(src)




  // Object.entries(operations).forEach(([op, data]) => {
  //   console.log(op)
  //   console.log(data)
  // });

  // console.log(operations)


  // return operations;
}
